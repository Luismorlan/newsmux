# GraphQL schema

enum FeedRefreshDirection {
  NEW
  OLD
}

# TODO(jamie): more documentations on all APIs
type Query {
  allFeeds: [Feed!]
  sources: [Source!]
  subSources: [SubSource!]
  posts: [Post!]
  users: [User!]
  feeds(input: FeedsForUserInput): [Feed!]!
}

input NewUserInput {
  id: String!
  name: String!
}

input NewFeedInput {
  userId: String!
  name: String!
  filterDataExpression: String!
  sourceIds: [String!]!
  subSourceIds: [String!]!
}

# TODO: for testing purpose, real post is created by crawler and publisher
input NewPostInput {
  title: String!
  content: String!
  sourceId: String!
  subSourceId: String
  feedsIdPublishTo: [String!]
  sharedFromPostId: String
}

input SubscribeInput {
  userId: String!
  feedId: String!
}

input NewSourceInput {
  userId: String!
  name: String!
  domain: String!
}

input NewSubSourceInput {
  userId: String!
  name: String!
  externalIdentifier: String!
  sourceId: String!
}

input FeedRefreshInput {
  feedId: String!
  limit: Int!
  cursor: Int!
  direction: FeedRefreshDirection!
  feedUpdatedTime: Time
}

input FeedsForUserInput {
  userId: String!
  feedRefreshInputs: [FeedRefreshInput!]!
}

type Mutation {
  createUser(input: NewUserInput!): User!
  createFeed(input: NewFeedInput!): Feed!
  # TODO: for testing purpose, real post is created by crawler and publisher
  createPost(input: NewPostInput!): Post!
  # TODO: what should be a better output
  subscribe(input: SubscribeInput!): User!

  createSource(input: NewSourceInput!): Source!
  createSubSource(input: NewSubSourceInput!): SubSource!
  syncUp(input: SeedStateInput): SeedState
}

type Subscription {
  syncDown(userId: String!): SeedState!
}

scalar Time
